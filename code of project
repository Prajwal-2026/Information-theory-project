import pywt
import numpy as np
from PIL import Image
import heapq, os
from collections import Counter
import cv2
import pandas as pd
from skimage.metrics import structural_similarity as ssim

def calculate_metrics(original, compressed):
    mse = np.mean((original.astype(float) - compressed.astype(float)) ** 2)
    psnr = 20 * np.log10(255.0 / np.sqrt(mse)) if mse > 0 else float('inf')
    ssim_val = ssim(original, compressed, multichannel=True, channel_axis=-1, data_range=255)
    return {'MSE': mse, 'PSNR': psnr, 'SSIM': ssim_val}

# --- Detect Central Dense Cell (Expanded ROI) ---
def detect_central_cell_roi_rgb(image_rgb, min_area=200, circularity_thresh=0.6, expand=10):
    hsv = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2HSV)
    s_channel = hsv[:, :, 1]
    blurred = cv2.GaussianBlur(s_channel, (5, 5), 0)
    _, thresh = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    best_contour, max_score = None, 0

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < min_area:
            continue
        perimeter = cv2.arcLength(cnt, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * (area / (perimeter ** 2))
        if circularity > circularity_thresh and area * circularity > max_score:
            best_contour = cnt
            max_score = area * circularity

    if best_contour is not None:
        x, y, w, h = cv2.boundingRect(best_contour)
        return (
            max(0, x - expand), 
            max(0, y - expand), 
            min(image_rgb.shape[1], x + w + expand), 
            min(image_rgb.shape[0], y + h + expand)
        )
    return None

# --- Create ROI Mask ---
def create_roi_mask(img_shape, roi_coords, blend_width=10):
    h, w = img_shape[:2]
    mask = np.zeros((h, w), dtype=bool)
    blend_mask = np.zeros((h, w), dtype=float)

    if roi_coords:
        x1, y1, x2, y2 = [max(0, min(val, lim)) for val, lim in zip(roi_coords, [w, h, w, h])]
        core_x1, core_y1 = x1 + blend_width, y1 + blend_width
        core_x2, core_y2 = x2 - blend_width, y2 - blend_width

        if core_x2 > core_x1 and core_y2 > core_y1:
            mask[core_y1:core_y2, core_x1:core_x2] = True
            blend_mask[core_y1:core_y2, core_x1:core_x2] = 1.0

        for y in range(y1, y2):
            for x in range(x1, x2):
                if not mask[y, x]:
                    dist = min(x - x1, x2 - x - 1, y - y1, y2 - y - 1)
                    if dist < blend_width:
                        blend_mask[y, x] = min(1.0, dist / blend_width)
    return mask, blend_mask

# --- Paths ---
root_folder = "C:/Users/Asus/Desktop/IT project/DATA SET"
output_root = "C:/Users/Asus/Desktop/IT project/output_rgb1"
os.makedirs(output_root, exist_ok=True)

results_data = []

# --- Process Images ---
for subdir, _, files in os.walk(root_folder):
    for file in files:
        if not file.lower().endswith(('.jpg', '.jpeg', '.png')):
            continue

        img_path = os.path.join(subdir, file)
        rel_path = os.path.relpath(subdir, root_folder)
        out_folder = os.path.join(output_root, rel_path)
        os.makedirs(out_folder, exist_ok=True)

        img_rgb = np.array(Image.open(img_path).convert("RGB"))
        height, width, _ = img_rgb.shape
        print(f"\nProcessing: {file} ({width}x{height})")

        # --- Detect ROI ---
        roi_coords = detect_central_cell_roi_rgb(img_rgb, expand=10)
        if roi_coords is None:
            print("No ROI found. Skipping...")
            continue

        roi_mask, blend_mask = create_roi_mask(img_rgb.shape, roi_coords, blend_width=15)
        blend_mask_3ch = np.stack([blend_mask] * 3, axis=-1)

        # --- Full Image Compression on RGB ---
        compressed_channels = []
        encoded_total_bits = 0

        for c in range(3):  # R, G, B channels
            channel = img_rgb[:, :, c]
            if height % 2 or width % 2:
                channel = np.pad(channel, ((0, height % 2), (0, width % 2)), mode='edge')
            LL, (LH, HL, HH) = pywt.dwt2(channel, 'haar')
            LL_q = np.round(LL / 60).astype(int)

            freq = Counter(LL_q.flatten())
            if len(freq) == 1:
                huff = {list(freq.keys())[0]: '0'}
                encoded = '0' * len(LL_q.flatten())
            else:
                heap = [[wt, [sym, ""]] for sym, wt in freq.items()]
                heapq.heapify(heap)
                while len(heap) > 1:
                    lo, hi = heapq.heappop(heap), heapq.heappop(heap)
                    for pair in lo[1:]: pair[1] = '0' + pair[1]
                    for pair in hi[1:]: pair[1] = '1' + pair[1]
                    heapq.heappush(heap, [lo[0]+hi[0]] + lo[1:] + hi[1:])
                huff = dict(heap[0][1:])
                encoded = ''.join(huff[v] for v in LL_q.flatten())

            encoded_total_bits += len(encoded)

            # Huffman Decode
            reverse_huff = {v: k for k, v in huff.items()}
            decoded, code = [], ""
            for bit in encoded:
                code += bit
                if code in reverse_huff:
                    decoded.append(reverse_huff[code])
                    code = ""
            LL_d = np.array(decoded).reshape(LL.shape) * 60
            recon = np.clip(pywt.idwt2((LL_d, (np.zeros_like(LL_d),) * 3), 'haar'), 0, 255).astype(np.uint8)
            recon = recon[:height, :width]  # Crop if padded
            compressed_channels.append(recon)

        compressed_rgb = np.stack(compressed_channels, axis=-1)

        # --- Blend Original ROI + Compressed non-ROI ---
        final_img = np.clip((1 - blend_mask_3ch) * compressed_rgb + blend_mask_3ch * img_rgb, 0, 255).astype(np.uint8)

        # --- Calculate Metrics ---
        metrics = calculate_metrics(img_rgb, final_img)
        compression_ratio = img_rgb.size * 8 / encoded_total_bits

        # --- Save Results ---
        base_name = os.path.splitext(file)[0]
        Image.fromarray(img_rgb).save(os.path.join(out_folder, f"{base_name}_original.png"))
        Image.fromarray(final_img).save(os.path.join(out_folder, f"{base_name}_compressed.png"))

        # --- Store results for CSV ---
        results_data.append({
            'Filename': file, 'Width': width, 'Height': height,
            'Compressed_Bits_KB': encoded_total_bits/8000, 'Compression_Ratio': compression_ratio,
            'PSNR': metrics['PSNR'], 'SSIM': metrics['SSIM'], 'MSE': metrics['MSE']
        })

        print(f"ROI: {roi_coords}")
        print(f"Compressed Bits: {encoded_total_bits/1000:.1f} kb")
        print(f"Compression Ratio: {compression_ratio:.2f}x")
        print(f"PSNR: {metrics['PSNR']:.2f} dB, SSIM: {metrics['SSIM']:.3f}")

# --- Save to CSV ---
if results_data:
    pd.DataFrame(results_data).to_csv(os.path.join(output_root, "results.csv"), index=False)
    print(f"\nResults saved to results.csv")
